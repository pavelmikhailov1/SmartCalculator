#ifndef SRC_CALC_H
#define SRC_CALC_H

#include <ctype.h>
#include <math.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define OPERAND \
  0  ///< флаг, который сообщает о том, что узел добавляется в стек операторов
#define NUMBER \
  1  ///< флаг, который сообщает о том, что узел добавляется в стек чисел

#define OK 0  ///< работа прошла без ошибок (возвращаемое значение)
#define INCORRECT_EXPRESSION \
  1  ///< работа завершилась с ошибкой "Не корректное выражение" (возвращаемое
     ///< значение)
#define ERROR_CAlCULATION \
  2  ///< работа завершилась с ошибкой "Ошибка калькуляции" (возвращаемое
     ///< значение)

#define EPS \
  10e-9  ///< Макрос для сравнения чисел типа double с точностью до 9 знаков
         ///< после запятой
#define ERROR_CH \
  '!'  ///< Макрос, который сообщает, что в функциях парсинга при проверке
       ///< строки на валидность была найдена ошибка

#define VALID_CHARACTERS \
  "1234567890.()+-*/^modcsintaqrtlgx"  ///< для функции парсинга, которая
                                       ///< проверяет символы входной строки на
                                       ///< валидность
#define BINARY_OPERATORS \
  "+-*/^m"  ///< для функции парсинга, которая ищет во входной строке бинарные
            ///< операторы
#define FUNCTIONS \
  "sctbnvqzo"  ///< для функции парсинга, которая ищет во входной строке функции
               ///< и заменяет их на соответствующие символы

typedef struct credit
{
	double sum;
	int term;
	int interest_rate;
	int type;
	double monthly_payment;
	double overpayment;
	double* total_payment;
} Credit;

/*!
  Структура стека операторов
*/
typedef struct Stack_oper  // флаг 0
{
  char c;        ///< Оператор
  int priority;  ///< Приоритет оператора
  struct Stack_oper* next;  ///< Указатель на следущий элемент в стеке
} t_node_oper;

/*!
  Структура стека чисел
*/
typedef struct Stack_value  // флаг 1
{
  double val;  ///< Число
  struct Stack_value* next;  ///< Указатель на следущий элемент в стеке
} t_node_value;

/*!
  @brief Главная функция для рассчета арифметического выражения
  @param result В эту переменную будет записан результат калькуляции выражения
  @param str Входная строка с выражением
  @param x Значение X
  @return Статус ошибки : 0 - работа завершилась корректно, 1 - работа
  завершилась с ошибкой "Не корректное выражение"
*/
int calculator(char* str, double* result, double x);

//============FUNCTIONS FOR PARSER==============

/*!
  @brief Функция для парсинга входной строки, которая выполняет следующую
  работу: Проверка каждого символа строки на валидность; Определение чисел;
  Определение бинарных операторов;
  Определение унарных операторов;
  Определение функций с дальнейшей заменой их на соответствующие короткие
  обозначения(для удобства в дальнейшем формировании строки в обратной
  постфиксной записи).
  @param str Входная строка с выражением
  @param result Выходная строка с выражением, где были обработаны унарные
  @return Статус ошибки
*/
int parser(char* str, char* result);

/*!
  @brief Функция для дополнительной проверки строки на валидность
  @param str Входная строка с выражением
  @return Статус ошибки : 0 - работа завершилась корректно, 1 - работа
  завершилась с ошибкой "Не корректное выражение"
*/
int check_correct_string(char* str);

/*!
  @brief Функция определяет что за символ находится в строке
  @param str Входная строка с выражением
  @param err Переменная для отслеживания ошибки
  @return Символ, при условии, что он был корректным
*/
char get_character(char** str, int* err);

/*!
  @brief Функция определяет что в строке находится функция
  @param str Входная строка с выражением
  @return Специальный символ, полученный путем проверки строки на наличие
  корректно написанной функции
*/
char get_function(char** str);

/*!
  @brief Функция определяет что в строке находится тригонометрическая функция
  @param str Входная строка с выражением
  @return Специальный символ, полученный путем проверки строки на наличие
  корректно написанной функции
*/
char get_triginometric_func(char** str);

/*!
  @brief Функция определяет что в строке находится обратная тригонометрическая
  функция
  @param str Входная строка с выражением
  @return Специальный символ, полученный путем проверки строки на наличие
  корректно написанной функции
*/
char get_inverse_triginometric_func(char** str);

/*!
  @brief Функция определяет что в строке находится функция взятия корня
  @param str Входная строка с выражением
  @return Специальный символ, полученный путем проверки строки на наличие
  корректно написанной функции
*/
char get_sqrt_func(char** str);

/*!
  @brief Функция определяет что в строке находятся функции десятичного или
  натурального логарифма
  @param str Входная строка с выражением
  @return Специальный символ, полученный путем проверки строки на наличие
  корректно написанной функции
*/
char get_log_func(char** str);

/*!
  @brief Функция определяет что в строке находится функция взятия остатка от
  деления
  @param str Входная строка с выражением
  @return Специальный символ, полученный путем проверки строки на наличие
  корректно написанной функции
*/
char get_mod_func(char** str);

/*!
  @brief Функция определяет что в строке находятся число и переписывает его в
  выходную строку
  @param str Входная строка с выражением
  @param result Выходная строка с выражением
*/
void get_number(char** str, char* result);

/*!
  @brief Функция берет из строки число и возвращает его в качестве значения
  @param pointer Входная строка с выражением
  @return Число, взятое из строки
*/
double add_number_to_str(char** pointer);

/*!
  @brief Функция меняет в строке точки на запятые(особенности сборки проекта
  через cmake)
  @param str Входная строка с выражением
*/
void dot_replacement(char* str);

//================FUNCTIONS FOR STACK================

/*!
  @brief Функция выделяет память под новый узел стека
  @param flag_head Флаг для определения под узел какого типа будет выделяться
  память и сколько ее выделить
  @return Указатель на область памяти
*/
void* allocate(int flag_head);

/*!
  @brief Функция добавляет элемент на вершину стека
  @param head Указатель на текущий head
  @param c Указатель на значение
  @param priority Приоритет оператора в строке(только для стека с операторами)
  @param flag_head Флаг для определения в какой из стеков будет добавлен узел
  @return Указатель на новый head
*/
void* push(void* head, void* c, int priority, int flag_head);

/*!
  @brief Функция добавляет элемент на вершину стека
  @param head Указатель на текущий head
  @param flag_head Флаг для определения из какого стека будет удален узел
  @return Указатель на новый head
*/
void* pop(void* head, int flag_head);

/*!
  @brief Функция для освобождения памяти, выделенной под стек
  @param head Указатель на текущий head
  @param flag Флаг для определения того, какой стек будем освобождать
  @return Указатель на новый head
*/
void free_stack(void* head, int flag);

//============FUNCTIONS FOR CONVERT TO POLISH NOTATION==============

/*!
  @brief Функция для перевода строки из инфификсной записи в обратную польскую
  @param str Входная строка с выражением в инфиксной записи
  @param polish_str Выходная строка с выражением в обратной польской записи
  @param x Значение Х
  @return Статус ошибки : 0 - работа завершилась корректно, 1 - работа
  завершилась с ошибкой "Не корректное выражение"
*/
int infix_to_polish(char* str, char* polish_str, double x);

/*!
  @brief Функция для взятия приоритета оператора
  @param c Символ обозначающий оператор
  @return Приоритет оператора
*/
int get_priority(char c);

/*!
  @brief Функция помещает в выходную строку все операторы из стека пока не
  встретит открытую скобку или стек не окажется пустым
  @param t_node_oper Указатель на текущий head
  @param polish_str Выходная строка с обратной польской записью
  @param count_of_open_bracket Количество открытых скобок в выражении на текущий
  момент
  @return Статус ошибки : 0 - работа завершилась корректно, 1 - работа
  завершилась с ошибкой "Не корректное выражение"
*/
int stack_deallocation(t_node_oper** head_oper, char** polish_str,
                       int count_of_open_bracket);

/*!
  @brief Функция помещает в выходную строку функцию, если та была в выражении
  перед открытой скобкой
  @param t_node_oper Указатель на текущий head
  @param polish_str Выходная строка с обратной польской записью
  @param count_of_open_bracket Количество открытых скобок в выражении на текущий
  момент
  @param error Переменная для отслеживания ошибки
*/
void working_with_clozed_backet(t_node_oper** head_oper, char* polish_str,
                                int* count_of_open_bracket, int* error);

/*!
  @brief Функция помещает в выходную строку все оставшиеся в стеке операторы
  @param t_node_oper Указатель на текущий head
  @param polish_str Выходная строка с обратной польской записью
  @param error Переменная для отслеживания ошибки
*/
void add_operators_to_polish_string(t_node_oper** head_oper, char** polish_str,
                                    int* error);

/*!
  @brief Функция берет значение X и помещает его в выходную строку
  @param str Входная строка с инфиксной записью
  @param polish_str Выходная строка с обратной польской записью
  @param x Значение X
*/
void get_value_x(char** str, char** polish_str, double x);

//===============FUNCTIONS FOR CALCULATE====================

/*!
  @brief Функция считает выражение в обратной польской записи
  @param polish_str Входная строка с обратной польской записью
  @param result Переменная, где будет храниться результат выражения
  @return Статус ошибки : 0 - работа завершилась корректно, 2 - работа
  завершилась с ошибкой "Ошибка калькуляции"
*/
int calculate_polish_notation(char* polish_str, double* result);

/*!
  @brief Функция определяет текущий оператор(бинарный он или это функция)
  @param head_value Указатель на текущий head в стеке чисел
  @param ch Оператор
  @return Статус ошибки : 0 - работа завершилась корректно, 2 - работа
  завершилась с ошибкой "Ошибка калькуляции"
*/
int calculate_values(t_node_value** head_value, char ch);

/*!
  @brief Функция определяет текущий бинарный оператор
  @param head_value Указатель на текущий head в стеке чисел
  @param ch Оператор
  @return Статус ошибки : 0 - работа завершилась корректно, 2 - работа
  завершилась с ошибкой "Ошибка калькуляции"
*/
int definition_operator_and_calculate(t_node_value** head_value, char ch);

/*!
  @brief Функция определяет текущий функцию в строке
  @param head_value Указатель на текущий head в стеке чисел
  @param ch Оператор
  @return Статус ошибки : 0 - работа завершилась корректно, 2 - работа
  завершилась с ошибкой "Ошибка калькуляции"
*/
int definition_function_and_calculate(t_node_value** head_value, char ch);

/*!
  @brief Функция берет значение в стеке чисел и удаляет верхний элемент в стеке
  @param head_value Указатель на текущий head в стеке чисел
  @return Значение
*/
double get_value_and_delete_node(t_node_value** head_value);

#endif  // SRC_CALC_H